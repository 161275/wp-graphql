{
    "docs": [
        {
            "location": "/", 
            "text": "WPGraphQL - A free, open-source WordPress plugin that provides an extendable GraphQL schema and API for any WordPress site.\n\n\nYou are currently viewing the WPGraphQL docs and reference, where you can read about major concepts, dive into technical details or follow practical examples to learn how WPGraphQL works.\n\n\nWebsite\n \u2022\u00a0\nApiGen Code Docs\n \u2022\u00a0\nSlack\n\n\n\n\n\n\n\n\n\n\nBeta Software Notice\n\n\nUntil WPGraphQL hits a \n1.0.0 release\n, it is still considered beta software. This doesn't mean that the plugin isn't ready for use, it just means that there \nmight\n still be \nbugs\n and that there \nmight\n be breaking changes to the shape of the API or internal functions as we work toward a stable release. \n\n\nDon't hesitate to start using the plugin, but just be sure to follow along with \nreleases\n \nand keep up to date with conversations in \nSlack (join here)\n \n\n\nWPGraphQL is already in use in production on several sites, including \nwork.qz.com\n, \nhopelabs.org\n and more.\n\n\n\n\nWhat is WPGraphQL?\n\n\nWPGraphQL is A free, open-source WordPress plugin that provides an extendable \nGraphQL\n GraphQL Schema and API for any WordPress site.\n\n\nWPGraphQL provides a GraphQL API and \n/graphql\n endpoint for your WordPress site, allowing for interaction with WordPress data using \nGraphQL Queries and Mutations\n.\n\n\nWhat is GraphQL?\n\n\nGraphQL is an open source technical specification, developed and maintained by Facebook, for an application level query language. \n\n\nWhat does that mean? Basically GraphQL provides a consistent way to make declarative queries, which will enable you to more easily retrieve the data you want, and the shape that you want it in. \n\n\nGraphQL can be implemented in any language and can cover a vast amount of use cases. \n\n\nWPGraphQL exposes a WordPress installation's data through a GraphQL API. You can send a GraphQL request over HTTP to the \n/graphql\n endpoint provided by the plugin and in response you will get the matching JSON representation of your data.\n\n\n\n\nInfo\n\n\nYou can also use GraphQL Queries and Mutations from within WordPress PHP without the need for HTTP network requests. \nLearn more\n\n\n\n\nWhy use WPGraphQL?\n\n\nWPGraphQL is arguably the easiest \nand\n most efficient way to interact with WordPress data.\n\n\nGraphQL enables small, efficient responses by only retrieving and returning exactly what was asked for, and nothing more.\n\n\nWPGraphQL helps reduce:\n\n\n\n\nHTTP Requests:\n Multiple resources can be fetched in a single request\n\n\nResponse size:\n Only the fields asked for are returned minimizing the payload downloaded by the client\n\n\nEndpoint Bloat:\n GraphQL provides a single endpoint and allows clients to ask for what they want from the single source. No need to memorize and maintain various feature endpoints.\n\n\nExternal Documentation:\n GraphQL is self-documenting, reducing the time and resources needed for maintaining API documentation\n\n\nTotal SQL queries:\n GraphQL queries can ask for multiple resources, or nested resources in a single request allowing GraphQL to determine the most efficient way to get the data from the database with as few SQL queries as possible.\n\n\nCode Duplication:\n Because GraphQL exposes all server capabilities in a single Schema, there's no need to duplicate code for various endpoints. The client can control the shape of their model without specific feature endpoint, which typically requires duplicate server code.\n\n\n\n\nWPGraphQL helps improve:\n\n\n\n\nPerformance:\n WPGraphQL utilizies existing WordPress Core APIs, such as WP_Query, so caching and filters are respected, but WPGraphQL also makes use of deferred resolvers and some look-ahead techniques (as all fields are known in the request before execution begins), allowing for data to be fetched and returned with as few SQL queries as possible. \n\n\nDeveloper Happiness:\n The strong-type system and explicit nature of GraphQL requests makes it easy for developers to understand GraphQL query and mutation requests long after code is written. Additionally, code duplication is drastically reduced as the API is defined in one spot, not in feature endpoints.\n\n\nVersioning:\n REST APIs and other APIs can be difficult to version. GraphQL makes \nevolving the API\n much easier than how other APIs are versioned. \n\n\n\n\nHow does WPGraphQL Work?", 
            "title": "About"
        }, 
        {
            "location": "/#what-is-wpgraphql", 
            "text": "WPGraphQL is A free, open-source WordPress plugin that provides an extendable  GraphQL  GraphQL Schema and API for any WordPress site.  WPGraphQL provides a GraphQL API and  /graphql  endpoint for your WordPress site, allowing for interaction with WordPress data using  GraphQL Queries and Mutations .", 
            "title": "What is WPGraphQL?"
        }, 
        {
            "location": "/#what-is-graphql", 
            "text": "GraphQL is an open source technical specification, developed and maintained by Facebook, for an application level query language.   What does that mean? Basically GraphQL provides a consistent way to make declarative queries, which will enable you to more easily retrieve the data you want, and the shape that you want it in.   GraphQL can be implemented in any language and can cover a vast amount of use cases.   WPGraphQL exposes a WordPress installation's data through a GraphQL API. You can send a GraphQL request over HTTP to the  /graphql  endpoint provided by the plugin and in response you will get the matching JSON representation of your data.   Info  You can also use GraphQL Queries and Mutations from within WordPress PHP without the need for HTTP network requests.  Learn more", 
            "title": "What is GraphQL?"
        }, 
        {
            "location": "/#why-use-wpgraphql", 
            "text": "WPGraphQL is arguably the easiest  and  most efficient way to interact with WordPress data.  GraphQL enables small, efficient responses by only retrieving and returning exactly what was asked for, and nothing more.  WPGraphQL helps reduce:   HTTP Requests:  Multiple resources can be fetched in a single request  Response size:  Only the fields asked for are returned minimizing the payload downloaded by the client  Endpoint Bloat:  GraphQL provides a single endpoint and allows clients to ask for what they want from the single source. No need to memorize and maintain various feature endpoints.  External Documentation:  GraphQL is self-documenting, reducing the time and resources needed for maintaining API documentation  Total SQL queries:  GraphQL queries can ask for multiple resources, or nested resources in a single request allowing GraphQL to determine the most efficient way to get the data from the database with as few SQL queries as possible.  Code Duplication:  Because GraphQL exposes all server capabilities in a single Schema, there's no need to duplicate code for various endpoints. The client can control the shape of their model without specific feature endpoint, which typically requires duplicate server code.   WPGraphQL helps improve:   Performance:  WPGraphQL utilizies existing WordPress Core APIs, such as WP_Query, so caching and filters are respected, but WPGraphQL also makes use of deferred resolvers and some look-ahead techniques (as all fields are known in the request before execution begins), allowing for data to be fetched and returned with as few SQL queries as possible.   Developer Happiness:  The strong-type system and explicit nature of GraphQL requests makes it easy for developers to understand GraphQL query and mutation requests long after code is written. Additionally, code duplication is drastically reduced as the API is defined in one spot, not in feature endpoints.  Versioning:  REST APIs and other APIs can be difficult to version. GraphQL makes  evolving the API  much easier than how other APIs are versioned.", 
            "title": "Why use WPGraphQL?"
        }, 
        {
            "location": "/#how-does-wpgraphql-work", 
            "text": "", 
            "title": "How does WPGraphQL Work?"
        }, 
        {
            "location": "/install-and-activate/", 
            "text": "Recommended Version\n\n\nFor the most stable and performant experience, it's recommended that you use the \nmost recent\n version of the plugin. You can \nsee the latest releases here\n.\n\n\nOf course, as new features are in development, feel free to check out the latest \ndevelop\n branch or check out any other feature or release.\n\n\nDownload / Clone the Plugin\n\n\nWPGraphQL is available on Github: \nhttps://github.com/wp-graphql/wp-graphql\n\n\nYou can download the plugin or clone the plugin from \nGithub\n.\n\n\nAdd the downloaded/cloned plugin to your WordPress plugin directory. On a typical WordPress install, this is located at \n/wp-content/plugins\n\n\n\n\nNOTE:\n The plugin directory should be \nwp-graphql\n and not something like \nwp-graphql-master\n or \nwp-graphql-develop\n\n\n\n\nActivate the Plugin\n\n\nOnce the plugin is in the WordPress plugins directory, it can be activated by clicking \"Activate\" on the plugin screen, or via WP CLI \nwp plugin activate wp-graphql\n\n\nVerify the Endpoint Works\n\n\nThe most common use of WPGraphQL is as an API endpoint that can be accessed via HTTP requests (\nalthough it can be used without remote HTTP requests as well\n)\n\n\nIn order for the \n/graphql\n endpoint to work, you must have \npretty permalinks\n enabled and any permalink structure \nother\n than the default WordPress permalink structure.\n\n\nOnce the plugin is active, your site should have a \nyoursite.com/graphql\n endpoint and you the expected response is a JSON payload like so:\n\n\n{\n\n    \nerrors\n:\n \n[\n\n        \n{\n\n            \nmessage\n:\n \nGraphQL requests must be a POST or GET Request with a valid query\n,\n\n            \ncategory\n:\n \nuser\n\n        \n}\n\n    \n]\n\n\n}\n\n\n\n\n\n\nIf you see anything else, such as your site's 404 page, you may need to \nflush permalinks\n.\n\n\nFlush Permalinks\n\n\nActivating the plugin \nshould\n cause the permalinks to flush. Occasionally, this doesn't work. If you have a permalink structure other than the default WordPress structure, and the plugin is active but nothing shows at your site's \n/graphql\n endpoint, try to manually flush your permalinks by:\n\n\n\n\nFrom your WordPress dashboard, visit the \nSettings \n Permalinks\n page. Just visiting the page should flush the permalinks\n\n\n\n\nor\n\n\n\n\nUsing WP CLI run \nwp rewrite flush\n\n\n\n\nUsing the Plugin without the /graphql Endpoint\n\n\nWPGraphQL can be used from the context of WordPress PHP and doesn't require HTTP requests to be used. You can completely remove the \n/graphql\n endpoint that the plugin provides so that the API is not available publicly in \nany way\n but still use GraphQL in your plugin and theme code by using:\n\n\ndo_graphql_request()\n\n\n\n\n\n\nLearn more about using WPGraphQL in PHP, without making HTTP requests\n.", 
            "title": "Plugin Install & Activation"
        }, 
        {
            "location": "/install-and-activate/#recommended-version", 
            "text": "For the most stable and performant experience, it's recommended that you use the  most recent  version of the plugin. You can  see the latest releases here .  Of course, as new features are in development, feel free to check out the latest  develop  branch or check out any other feature or release.", 
            "title": "Recommended Version"
        }, 
        {
            "location": "/install-and-activate/#download-clone-the-plugin", 
            "text": "WPGraphQL is available on Github:  https://github.com/wp-graphql/wp-graphql  You can download the plugin or clone the plugin from  Github .  Add the downloaded/cloned plugin to your WordPress plugin directory. On a typical WordPress install, this is located at  /wp-content/plugins   NOTE:  The plugin directory should be  wp-graphql  and not something like  wp-graphql-master  or  wp-graphql-develop", 
            "title": "Download / Clone the Plugin"
        }, 
        {
            "location": "/install-and-activate/#activate-the-plugin", 
            "text": "Once the plugin is in the WordPress plugins directory, it can be activated by clicking \"Activate\" on the plugin screen, or via WP CLI  wp plugin activate wp-graphql", 
            "title": "Activate the Plugin"
        }, 
        {
            "location": "/install-and-activate/#verify-the-endpoint-works", 
            "text": "The most common use of WPGraphQL is as an API endpoint that can be accessed via HTTP requests ( although it can be used without remote HTTP requests as well )  In order for the  /graphql  endpoint to work, you must have  pretty permalinks  enabled and any permalink structure  other  than the default WordPress permalink structure.  Once the plugin is active, your site should have a  yoursite.com/graphql  endpoint and you the expected response is a JSON payload like so:  { \n     errors :   [ \n         { \n             message :   GraphQL requests must be a POST or GET Request with a valid query , \n             category :   user \n         } \n     ]  }   If you see anything else, such as your site's 404 page, you may need to  flush permalinks .", 
            "title": "Verify the Endpoint Works"
        }, 
        {
            "location": "/install-and-activate/#flush-permalinks", 
            "text": "Activating the plugin  should  cause the permalinks to flush. Occasionally, this doesn't work. If you have a permalink structure other than the default WordPress structure, and the plugin is active but nothing shows at your site's  /graphql  endpoint, try to manually flush your permalinks by:   From your WordPress dashboard, visit the  Settings   Permalinks  page. Just visiting the page should flush the permalinks   or   Using WP CLI run  wp rewrite flush", 
            "title": "Flush Permalinks"
        }, 
        {
            "location": "/install-and-activate/#using-the-plugin-without-the-graphql-endpoint", 
            "text": "WPGraphQL can be used from the context of WordPress PHP and doesn't require HTTP requests to be used. You can completely remove the  /graphql  endpoint that the plugin provides so that the API is not available publicly in  any way  but still use GraphQL in your plugin and theme code by using:  do_graphql_request()   Learn more about using WPGraphQL in PHP, without making HTTP requests .", 
            "title": "Using the Plugin without the /graphql Endpoint"
        }, 
        {
            "location": "/quickstart/frontend/", 
            "text": "", 
            "title": "Frontend"
        }, 
        {
            "location": "/quickstart/backend/", 
            "text": "", 
            "title": "Backend"
        }, 
        {
            "location": "/tutorials/using-graphiql-to-explore-docs-and-schema/", 
            "text": "", 
            "title": "Using GraphiQL to explore the Schema and Docs"
        }, 
        {
            "location": "/tutorials/custom-post-types-and-taxonomies/", 
            "text": "", 
            "title": "Custom Post Types & Taxonomies"
        }, 
        {
            "location": "/tutorials/add-fields-to-schema/", 
            "text": "", 
            "title": "Adding Fields to the Schema"
        }, 
        {
            "location": "/tutorials/use-graphql-in-php-without-http-request/", 
            "text": "", 
            "title": "Using WPGraphQL in PHP without HTTP requests"
        }, 
        {
            "location": "/tutorials/override-field-resolvers/", 
            "text": "", 
            "title": "Overriding Field Resolvers"
        }, 
        {
            "location": "/tutorials/unit-testing-wpgraphql/", 
            "text": "", 
            "title": "Unit Testing WPGraphQL"
        }, 
        {
            "location": "/tutorials/unit-testing-extensions/", 
            "text": "", 
            "title": "Unit Testing your code that extends WPGraphQL"
        }, 
        {
            "location": "/reference/types-and-schema/", 
            "text": "", 
            "title": "GraphQL Types & Schema"
        }, 
        {
            "location": "/reference/actions-filters/", 
            "text": "", 
            "title": "Actions & Filters"
        }, 
        {
            "location": "/reference/auth/", 
            "text": "", 
            "title": "Auth"
        }, 
        {
            "location": "/reference/extensions/", 
            "text": "", 
            "title": "Extensions"
        }, 
        {
            "location": "/faq/", 
            "text": "FAQ\n\n\nHow to use Custom Post Types and Custom Taxonomies?\n\n\nIt's pretty common to want to expose Custom Post Type and Custom Taxonomies in WPGraphQL. We have tutorials written up on how to do this!\n\n\nLearn more about using Custom Post Types \n Taxonomies with WPGraphQL\n\n\nHow to override a field's resolver?\n\n\nSometimes you need granular control over how a specific field resolves. Field resolvers can easily be filtered so that you can control what is returned.\n\n\nLearn more about overriding Field resolvers\n\n\nWhat's up with \"edges\" and \"nodes\"?\n\n\nGraphQL itself makes no mandates on the shape of a Schema. This is great, but can also be problematic as a poorly defined schema can be difficult to use, extend, and version.\n\n\nThe shape of the WPGraphQL Schema is inspired heavily by the \nRelay spec\n.\n\n\nThe Relay spec introduces the concept of \nConnections\n. \n\n\nLet's compare what a naiive schema and a schema with Relay connections looks like.\n\n\nNaive Schema\n\n\n{\n  posts {\n    id\n    title\n    date\n  }\n}\n\n\n\n\n\nConnection Schema\n\n\n{\n  posts {\n    edges {\n      node {\n        id\n        title\n        date\n      }\n    }\n  }\n}\n\n\n\n\n\nThe \nedges\n serve as a place for where \"edge\" data can be exposed. The most common example is pagination cursors. \n\n\nPagination\n\n\nIn the \nnaiive schema\n, we just get a list of posts back. There's no data exposed that references where each\npost belongs in the larger data set. For pagination to work well, we need to be able to pass data back in our next query\nto indicate what posts we want to query next. \n\n\nThe cursor for a connection can be queried like so:\n\n\n{\n  posts {\n    pageInfo {\n      hasNextPage\n      hasPreviousPage\n      startCursor\n      endCursor\n    }\n    edges {\n      cursor\n      node {\n        id\n        title\n        date\n      }\n    }\n  }\n}\n\n\n\n\n\nHere we ask for \npageInfo\n on the connection itself, where we ask for the \nstartCursor\n and \nendCursor\n. Additionally we ask for a cursor\nfor each \"node\" in the connection. \n\n\nThe cursor can be used as a reference to where in the overall data-set we are, and can be used to tell WPGraphQL where to start\nthe next query.\n\n\nFor example, if we queried for 10 items, and wanted to paginate through asking for the next 10 items, we could do so by first asking for 10 posts:\n\n\n{\n   posts( first: 10 ) {\n       pageInfo {\n         hasNextPage\n         hasPreviousPage\n         startCursor\n         endCursor\n       }\n       edges {\n         cursor\n         node {\n           id\n           title\n           date\n         }\n       }\n   }\n}\n\n\n\n\n\nThen, we would store the \nendCursor\n as a variable \n$endCursor = query.posts.pageInfo.endCursor\n and use that to tell WPGraphQL where to start the next query, like so:\n\n\n{\n   posts( first: 10, after: $endCursor ) {\n       pageInfo {\n         hasNextPage\n         hasPreviousPage\n         startCursor\n         endCursor\n       }\n       edges {\n         cursor\n         node {\n           id\n           title\n           date\n         }\n       }\n   }\n}\n\n\n\n\n\n\n\nLearn more about using Variables with GraphQL\n\n\nThis is a basic example showing how to use variables. As you work with GraphQL more, there are better ways to handle variables in your GraphQL requests. \nLearn more about GraphQL variables\n\n\n\n\nHow many houses are in Iowa?\n\n\nNot sure why this is frequently asked, but you won't find the answer here...\n\n\nWhat if I have a new question?\n\n\nIf you have a question that isn't answered in the FAQ or in any of Tutorials or Reference guide, feel free to create an issue in Github, but be as specific and detailed as possible to give us the best chance to help you. \n\n\nAdditionally, you can reach out to the greater WPGraphQL community on Slack: \njoin here", 
            "title": "FAQs"
        }, 
        {
            "location": "/faq/#faq", 
            "text": "", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#how-to-use-custom-post-types-and-custom-taxonomies", 
            "text": "It's pretty common to want to expose Custom Post Type and Custom Taxonomies in WPGraphQL. We have tutorials written up on how to do this!  Learn more about using Custom Post Types   Taxonomies with WPGraphQL", 
            "title": "How to use Custom Post Types and Custom Taxonomies?"
        }, 
        {
            "location": "/faq/#how-to-override-a-fields-resolver", 
            "text": "Sometimes you need granular control over how a specific field resolves. Field resolvers can easily be filtered so that you can control what is returned.  Learn more about overriding Field resolvers", 
            "title": "How to override a field's resolver?"
        }, 
        {
            "location": "/faq/#whats-up-with-edges-and-nodes", 
            "text": "GraphQL itself makes no mandates on the shape of a Schema. This is great, but can also be problematic as a poorly defined schema can be difficult to use, extend, and version.  The shape of the WPGraphQL Schema is inspired heavily by the  Relay spec .  The Relay spec introduces the concept of  Connections .   Let's compare what a naiive schema and a schema with Relay connections looks like.", 
            "title": "What's up with \"edges\" and \"nodes\"?"
        }, 
        {
            "location": "/faq/#naive-schema", 
            "text": "{\n  posts {\n    id\n    title\n    date\n  }\n}", 
            "title": "Naive Schema"
        }, 
        {
            "location": "/faq/#connection-schema", 
            "text": "{\n  posts {\n    edges {\n      node {\n        id\n        title\n        date\n      }\n    }\n  }\n}  The  edges  serve as a place for where \"edge\" data can be exposed. The most common example is pagination cursors.   Pagination  In the  naiive schema , we just get a list of posts back. There's no data exposed that references where each\npost belongs in the larger data set. For pagination to work well, we need to be able to pass data back in our next query\nto indicate what posts we want to query next.   The cursor for a connection can be queried like so:  {\n  posts {\n    pageInfo {\n      hasNextPage\n      hasPreviousPage\n      startCursor\n      endCursor\n    }\n    edges {\n      cursor\n      node {\n        id\n        title\n        date\n      }\n    }\n  }\n}  Here we ask for  pageInfo  on the connection itself, where we ask for the  startCursor  and  endCursor . Additionally we ask for a cursor\nfor each \"node\" in the connection.   The cursor can be used as a reference to where in the overall data-set we are, and can be used to tell WPGraphQL where to start\nthe next query.  For example, if we queried for 10 items, and wanted to paginate through asking for the next 10 items, we could do so by first asking for 10 posts:  {\n   posts( first: 10 ) {\n       pageInfo {\n         hasNextPage\n         hasPreviousPage\n         startCursor\n         endCursor\n       }\n       edges {\n         cursor\n         node {\n           id\n           title\n           date\n         }\n       }\n   }\n}  Then, we would store the  endCursor  as a variable  $endCursor = query.posts.pageInfo.endCursor  and use that to tell WPGraphQL where to start the next query, like so:  {\n   posts( first: 10, after: $endCursor ) {\n       pageInfo {\n         hasNextPage\n         hasPreviousPage\n         startCursor\n         endCursor\n       }\n       edges {\n         cursor\n         node {\n           id\n           title\n           date\n         }\n       }\n   }\n}   Learn more about using Variables with GraphQL  This is a basic example showing how to use variables. As you work with GraphQL more, there are better ways to handle variables in your GraphQL requests.  Learn more about GraphQL variables", 
            "title": "Connection Schema"
        }, 
        {
            "location": "/faq/#how-many-houses-are-in-iowa", 
            "text": "Not sure why this is frequently asked, but you won't find the answer here...", 
            "title": "How many houses are in Iowa?"
        }, 
        {
            "location": "/faq/#what-if-i-have-a-new-question", 
            "text": "If you have a question that isn't answered in the FAQ or in any of Tutorials or Reference guide, feel free to create an issue in Github, but be as specific and detailed as possible to give us the best chance to help you.   Additionally, you can reach out to the greater WPGraphQL community on Slack:  join here", 
            "title": "What if I have a new question?"
        }, 
        {
            "location": "/community-and-support/", 
            "text": "Support", 
            "title": "Community & Support"
        }, 
        {
            "location": "/community-and-support/#support", 
            "text": "", 
            "title": "Support"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributing", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contributing", 
            "text": "", 
            "title": "Contributing"
        }
    ]
}